using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.MSBuild;
using Neurotoxin.ScOut.Analysis;
using Neurotoxin.ScOut.Extensions;
using Neurotoxin.ScOut.Models;
using Neurotoxin.ScOut.Visitors;
using Project = Neurotoxin.ScOut.Models.Project;
using Solution = Neurotoxin.ScOut.Models.Solution;

namespace Neurotoxin.ScOut
{
    public class RoslynAnalyzer
    {
        private readonly List<string> _solutions = new List<string>();
        private  readonly List<string> _excludeFiles = new List<string>
        { 
            @"AssemblyInfo.cs$",
            @"[^\w]AssemblyAttributes.cs$",
            @"Settings.Designer.cs$",
            @" References\\.*?\\Reference.cs$" //TODO: temporary filtering only
        };

        static RoslynAnalyzer()
        {
            MSBuildLocator.RegisterDefaults();
        }

        public RoslynAnalyzer AddSolution(string path)
        {
            _solutions.Add(path);
            return this;
        }

        public RoslynAnalyzer AddSolutions(IEnumerable<string> path)
        {
            _solutions.AddRange(path);
            return this;
        }

        public RoslynAnalyzer ExcludeFiles(params string[] rule)
        {
            _excludeFiles.AddRange(rule);
            return this;
        }

        public AnalysisResult Analyze()
        {
            var result = new AnalysisResult
            {
                Solutions = _solutions.Select(MapSolution).ToArray()
            };
            return result;
        }

        private Solution MapSolution(string path)
        {
            var workspace = MSBuildWorkspace.Create();
            var sln = workspace.OpenSolutionAsync(path).GetAwaiter().GetResult();
            //TODO: logger
            //foreach (var log in workspace.Diagnostics.Where(d => d.Kind == WorkspaceDiagnosticKind.Failure))
            //{
            //    Console.WriteLine(log);
            //}
            return new Solution
            {
                Path = sln.FilePath,
                Projects = sln.Projects.Select(MapProject).ToArray()
            };
        }

        private Project MapProject(Microsoft.CodeAnalysis.Project proj)
        {
            var compilation = proj.GetCompilationAsync().GetAwaiter().GetResult();
            var trees = compilation.SyntaxTrees.ToArray();
            var sourceFiles = trees
                .Where(t => Path.GetExtension(t.FilePath) == ".cs")
                .Where(t => _excludeFiles.All(r => !new Regex(r).IsMatch(t.FilePath)));

            var mscorlibVersion = new Regex(@"v([\d\.]+)\\.*?mscorlib\.dll$");
            var project = new Project
            {
                Path = proj.FilePath,
                Language = proj.Language,
                LanguageVersion = proj.ParseOptions.Language,
                TargetFramework = proj.MetadataReferences.Select(m => mscorlibVersion.Match(m.Display)).FirstOrDefault(m => m.Success)?.Groups[1].Value
            };

            if (string.IsNullOrEmpty(project.TargetFramework)) Debugger.Break();

            foreach (var file in sourceFiles)
            {
                var visitor = new SourceFileVisitor();
                var x = visitor.Discover(file, compilation).ToArray();
            }

            return new Project
            {
                Path = proj.FilePath,
                Language = proj.Language,
                LanguageVersion = proj.ParseOptions.Language,
                //TargetFramework = GetTargetFramework(trees),
                //Classes = sourceFiles.SelectMany(file =>
                //{
                //    var root = file.GetRootAsync().GetAwaiter().GetResult();
                //    return root.FindNodes<ClassDeclarationSyntax>().Select(declaration => new
                //    {
                //        SourceFile = MapSourceFile(file),
                //        ClassDeclaration = declaration
                //    });
                //}).GroupBy(a => a.ClassDeclaration.Identifier.ValueText).ToDictionary(g => g.Key, g => MapClass(g))
            };
        }

        //private SourceFile MapSourceFile(SyntaxTree tree)
        //{

        //    return new SourceFile
        //    {
        //        Path = tree.FilePath,
        //        IsGenerated = tree.ToString().Contains("<auto-generated>"),
        //    };
        //}
    }
}